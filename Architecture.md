# Architecture & Stuff

## Parsing

### Framework

I used parser combinator library "BetterParse" because it has the most stars on Github
out of all Kotlin combinator libraries. Actually I found only two. The other had some 
nifty combinators (like `between '(' ')'`), but this one has a cool `Grammar` class that automatically registers tokens.  

So perhaps stars were a deciding factor.

I could've used a big parsing framework for Java (like antlr), but it seemed an overkill. Plus I remember antlr's 
autogenerated code to have a terrible interface.

### Implementation

![parsing diagram](/diagrams/Package%20parsing.png)

`NeshGrammar` parses lines of test into `Expression`-s of shell. Currently there are two types of `Expression`-s - assignments to variable and pipe chain of commands (each represented by `CommandExpr`).

It breaks a line into a list of sort-of-tokens of different types. I call them words. There are 4 types of them: a string in double quotes, in single quotes, a string of whitespace chars and a string of regular non-whitespace non quotes.

Each word is then processed by a corresponding `WordType` object, producing a `WordResolution`. It is basically a list of space-separated actual words with a flag. Usually last word of one `WordResolution` should be concatenated with the first word of the next `WordResolution`. Flag tells it not to.

The reason for this flag is a need to split words after resolving them. Example: `"a"$x"a"` if `x` is a bunch of spaces.

That's how it parses a list of space separated words (with variable substitution in the middle of the process). Having this, producing an `Expression` is easy.

## Command creation

![commands diagram](/diagrams/Package%20commands.png)

`Command` is an abstraction of, well, a command. It has input, output and it does something.

`Command`-s are created by factories. A factory is given words of a command and abstractions for input/output and can choose to create a command or not.

Command cat be executed. It blocks (or uses) shell's thread until command finishes execution.

`ExternalCommandFactory` creates `ExternalCommand`-s, which attempt to run an external program.

`FirstAcceptedFactory` has a list of other factories and returns first successfully created command. It is a design pattern which name a don't remember.

There is also a `BuiltinCommandFactory`, but it is not interesting.

## Intercommand Communication

Builtins want to get information from streams, and external programs want a `ProcessBuilder.Redirect`. So io abstractions provide both ways.

They also implement `Closeable`, but commands are not intended to close them.

![io diagram](/diagrams/Package%20io.png)

There are implementations for redirecting shell I/O and for redirecting to/from a file. 

Redirections to/from string are only for tests, they don't provide a `Redirect`.

Error stream is not redirected right now, so all commands scream their errors straight into shell process' error stream. It's not even hard to pass another Sink to all commands, but I'm too tired to add it.

## Interpreter

Interpreter interprets lines.

![Interpreter diagram](/diagrams/interpreter.png)

Interpreter uses provided Source and Sink as input and output. It comes handy in testing.

Interpreter manages pipe creation and deletion and Source/Sink closing. It requires a lot of try-catch-finally construction and each possible exception should be reported somehow. That's why it has a special `ProblemLogger` as a constructor argument.